/*****************************************************************************
 * Licensed to the Apache Software Foundation (ASF) under one                *
 * or more contributor license agreements.  See the NOTICE file              *
 * distributed with this work for additional information                     *
 * regarding copyright ownership.  The ASF licenses this file                *
 * to you under the Apache License, Version 2.0 (the                         *
 * "License"); you may not use this file except in compliance                *
 * with the License.  You may obtain a copy of the License at                *
 *                                                                           *
 *     http://www.apache.org/licenses/LICENSE-2.0                            *
 *                                                                           *
 * Unless required by applicable law or agreed to in writing,                *
 * software distributed under the License is distributed on an               *
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY                    *
 * KIND, either express or implied.  See the License for the                 *
 * specific language governing permissions and limitations                   *
 * under the License.                                                        *
 *                                                                           *
 *                                                                           *
 * This file is part of the BeanShell Java Scripting distribution.           *
 * Documentation and updates may be found at http://www.beanshell.org/       *
 * Patrick Niemeyer (pat@pat.net)                                            *
 * Author of Learning Java, O'Reilly & Associates                            *
 *                                                                           *
 *****************************************************************************/
/* Generated By:JJTree: Do not edit this line. src/bsh/JJTParserState.java */

package tsh;

public class JJTParserState {
    private java.util.Stack nodes;
    private java.util.Stack marks;

    private int sp;        // number of nodes on stack
    private int mk;        // current mark
    private boolean node_created;

    public JJTParserState() {
        nodes = new java.util.Stack();
        marks = new java.util.Stack();
        sp = 0;
        mk = 0;
    }

    /* Determines whether the current node was actually closed and
       pushed.  This should only be called in the final user action of a
       node scope.  */
    boolean nodeCreated() {
        return node_created;
    }

    /* Call this to reinitialize the node stack.  It is called
       automatically by the parser's ReInit() method. */
    public void reset() {
        nodes.removeAllElements();
        marks.removeAllElements();
        sp = 0;
        mk = 0;
    }

    /* Returns the root node of the AST.  It only makes sense to call
       this after a successful parse. */
    public Node rootNode() {
        return (Node) nodes.elementAt(0);
    }

    /* Pushes a node on to the stack. */
    void pushNode(Node n) {
        nodes.push(n);
        ++sp;
    }

    /* Returns the node on the top of the stack, and remove it from the
       stack.  */
    public Node popNode() {
        if (--sp < mk) {
            mk = ((Integer) marks.pop()).intValue();
        }
        return (Node) nodes.pop();
    }

    /* Returns the node currently on the top of the stack. */
    public Node peekNode() {
        return (Node) nodes.peek();
    }

    /* Returns the number of children on the stack in the current node
       scope. */
    public int nodeArity() {
        return sp - mk;
    }

    //出现异常时调用
    public void clearNodeScope(Node n) {
        while (sp > mk) {
            popNode();
        }
        mk = ((Integer) marks.pop()).intValue();
    }


    public void openNodeScope(Node n) {
        marks.push(new Integer(mk));
        mk = sp;
        n.jjtOpen();
    }

    /* 一个确定的节点由指定数量的子代构成。从堆栈中弹出该数量的节点，并将其作为确定节点的子代。然后将确定的节点压入堆栈。 */
    public void closeNodeScope(Node n, int num) {
        mk = ((Integer) marks.pop()).intValue();
        while (num-- > 0) {
            Node c = popNode();
            c.jjtSetParent(n);
            n.jjtAddChild(c, num);
        }
        n.jjtClose();
        pushNode(n);
        node_created = true;
    }


    /* 如果条件为真，则构造条件节点。自从节点打开以来，所有已推入的节点成为条件节点的子代，然后将其推入堆栈。如果条件为假，则不构造该节点，并且将它们保留在堆栈中。*/
    public void closeNodeScope(Node n, boolean condition) {
        if (condition) {
            int a = nodeArity();
            mk = ((Integer) marks.pop()).intValue();
            while (a-- > 0) {
                Node c = popNode();
                c.jjtSetParent(n);
                n.jjtAddChild(c, a);
            }
            n.jjtClose();
            pushNode(n);
            node_created = true;
        } else {
            mk = ((Integer) marks.pop()).intValue();
            node_created = false;
        }
    }

}
